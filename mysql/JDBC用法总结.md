#  :JDBC用法总结

[TOC]

## 1.jdbc操作数据库的基本步骤

### 1.1加载驱动类

```JAVA
Class.forName("com.mysql.jdbc.Driver")//针对mysql数据库
```

### 1.2创建数据库连接

```java
 DriverManager.getConnection(url,username,password);//getConnection有不同参数方法，这里最常用的是我列举的这种
```

### 1.3创建声明Statement

```java
Statement(静态SQL)：connection.createStatement();
PreparedStatement(动态SQL)：connection.prepareStatement(sql语句);
//动态sql在此处写sql语句， 在exceutexx就不需要写了，静态sql这里不用写sql语句， 下面就需要写。
```

### 1.4执行SQL

```java
1：executeQuery():在此PreparedStatement对象中执行SQL语句，并返回该查询生成的ResultSet对象。

2：executeUpdate():在此PreparedStatement对象中执行SQL语句，该语句必须是一个SQL数据操作语言(Date Manipulation Language，DML)语句，比如insert、update、delete语句；或者是无返内容的SQL语句，比如DDL语句 CREATE TABLE 和 DROP TABLE。

3：execute():在此PreparedStatement对象中执行SQL语句，该语句可以是任何种类的SQL语句。
```

### 1.5处理结果

```java
执行更新返回的是本次操作影响到的记录数
执行查询返回的是一个ResultSet对象
```

### 1.6关闭JDBC

```java
先关闭记录集（ResultSet）
再关闭声明（Statement）
最后关闭连接对象（Connection）
```



## 2.PreparedStatement介绍

​	PreparedStatement是Statement接口的子接口，属于预处理操作，与直接使用Statement不同，PreparedStatement在操作时，是预先在数据表中准备好了一条SQL语句，但是此SQL语句的具体内容暂时不设置，而是之后在进行设置。

​	PreparedStatement接口的技术原理:

PreparedStatement实例包含已编译的SQL语句，SQL语句可能包含1个，2个或多个输入的值，这些值未被明确指定在SQL语句中用？作为占位符代替，之后执行SQL语句之前要用setXXX()方法对值进行写入。

​      PreparedStatement对象比Statement对象的执行速度要快，因为PreparedStatement对象已经预编译过了，因此需要多次执行的SQL语句也可以用PreparedStatement对象进行执行来加快执行速度。

​      作为Statement的子类，PreparedStatement接口继承了Statement的所有功能。另外它还整合一整套getXXX()和setXXX()方法，用于对值得获取和输入设置。同时，它还修改了三个方法execute、executeQuery、executeUpdate使它们不需要参数。这些方法的Statement形式，不应该再用于PreparedStatement对象。

`prepareStatement(String sql)`

创建一个 PreparedStatement 对象来将参数化的 SQL 语句发送到数据库。

`prepareStatement(String sql,int autoGeneratedKeys)`

创建一个默认 PreparedStatement 对象，该对象能获取自动生成的键。

  

## 3.JDBC的批量操作

**Statement接口里有两个方法** 

```java
void     addBatch(String sql) //将给定的 SQL 命令添加到此 Statement 对象的当前命令列表中。通过									调用方法 executeBatch 可以批量执行此列表中的命令。
    
int[]     executeBatch()    //   将一批命令提交给数据库来执行，如果全部命令执行成功，则返回更新计数								   组成的数组。数组中的每个元素为：成功处理了命令后，执行命令所影响									 数据库中行数的更新计数
```

**PreparedStatement接口**

```java
void addBatch() throws SQLException;  //重写了addBatch()方法，<注意：PreparedStatement的																addBatch( )没有参数的>

int[]     executeBatch() 	          //executeBatch()并没有重写
```

addBatch()把若干sql语句装载到一起，然后一次送到数据库执行，执行需要很短的时间

而pstmt.executeUpdate() 是一条一条发往数据库执行的 时间都消耗在数据库连接的传输上面

举个例子可以帮助理解：

我这有一台超大功率的面粉加工机，前者相当于 把所有农户袋装的麦子收集起来用卡车一次送往加工厂 后者相当于农户排好队用同样的卡车一人一人的往加工厂送麦子 麦子加工5分钟完成，但是每个人到工厂就得3小时，我数据库执行效率再高也没用，时间都耗在传输的路上了！！

这就出现了数据传输的性能瓶颈 addBatch就是为解决这样的问题而产生的！

**PreparedStatement最重要的addbatch()结构的使用**

> 1.建立链接,(打电话拨号 )      Connection    connection =getConnection();



> 2.不自动 Commit (瓜子不是一个一个吃,全部剥开放桌子上,然后一口舔了)
>
> connection.setAutoCommit(false);  



> 3.预编译SQL语句,只编译一回哦,效率高啊.(发明一个剥瓜子的方法,以后不要总想怎么剥瓜子好.就这样剥.)
>
> PreparedStatement statement = connection.prepareStatement(“INSERT INTO TABLEX VALUES(?, ?)”);  



>4.来一个剥一个,然后放桌子上
>
>//记录1
>
>statement.setInt(1, 1);
>
>statement.setString(2, “Cujo”);
>
>statement.addBatch();//把这条执行语句加到PreparedStatement对象的批处理命令中
>
>//记录2
>
>statement.setInt(1, 2);
>
>statement.setString(2, “Fred”);
>
>statement.addBatch();//把这条执行语句加到PreparedStatement对象的批处理命令中
>
>//记录3
>
>statement.setInt(1, 3);
>
>statement.setString(2, “Mark”);
>
>statement.addBatch(); //把这条执行语句加到PreparedStatement对象的批处理命令中 



> 5.批量执行上面3条语句. 一口吞了,很爽
>
> int [] counts = statement.executeBatch();          //把以上添加到批处理命令中的所有命令一次过提交给数据库来执行 



> 6.Commit it 咽下去,到肚子(DB)里面   connection.commit();



具体代码：

```java
@Override
public Integer batchInsertSnachHotel(Collection<LmHotel> lmHotels) {
    if (lmHotels == null || lmHotels.size() == 0) {
        logger.info("添加数据为空!");
        return 0;
    }
    Connection conn = null;
    PreparedStatement stat = null;
    String sql = "INSERT INTO "+ TABLE_NAME + "(hotel_seq, city_url, hotel_name," +
            " from_date, to_date, priority, weight) VALUES (?,?,?,?,?,?,?)";
    logger.info("insert lmHotel into db:{}", sql);
    try {
        conn = infarDbBase.getInfarDbMasterConn(TABLE_NAME);
        conn.setAutoCommit(false);
        stat = conn.prepareStatement(sql);
        /**
         * set sql parameters.
         */
        for (LmHotel lmHotel : lmHotels) {
            stat.setString(1, lmHotel.getLmHotelSeq());
            stat.setString(2, lmHotel.getCityUrl());
            stat.setString(3, lmHotel.getLmHotelName());
            stat.setString(4, lmHotel.getFromDate());
            stat.setString(5, lmHotel.getToDate());
            stat.setInt(6, Integer.parseInt(lmHotel.getPriority()));
            stat.setDouble(7, Double.parseDouble(lmHotel.getWeight()));
            stat.addBatch();
        }
        stat.executeBatch();
        conn.commit();
    } catch (SQLException e) {
        try {
            conn.rollback();
        } catch (SQLException e1) {
            logger.error("error occured while rollback : batch insert lm_hotel," +
                    " sql : {}", sql);
        }
        logger.error("error occured while insert lmHotels, sql: {}", sql);
        return 0;
    } finally {
        DbUtil.close(null, stat, conn);
    }
    return 1;
}
```

```
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>

<style type="text/css">
   .table{font-size:12px;}
</style>

<script type="text/javascript">
</script>

<!-- 验证还是jquery-validation好用，这里省事没用 -->
<form id="warnPopForm" method="post" style="margin:0;text-align:center">
<%--<form id="warnPopForm" method="post" style="margin:0;text-align:center;overflow:hidden">--%>
    <table class="table" width="100%" border="0px">
      <!-- 隐藏域，否则更新的时候读不到这些值 -->
      <input type="hidden" name="id">
      <tr>
         <td width="100%" align="left">
                <%--
            <textarea name="invalid_str" id="invalid_str" readonly="readonly" style="width:99%;overflow-y:hidden" rows="10">
                --%>
                <textarea name="invalid_str" id="invalid_str" readonly="readonly" style="width:99%" rows="8">

            </textarea>
         </td>
      </tr>
      <tr>
         <td colspan="2" align="center">
            <a href="#" id="btn-back" onclick="closeWarnPopWindow();" class="easyui-linkbutton">关闭</a>
         </td>
      </tr>
   </table>
</form>
```



```
String key = TuiguangConstant.CACHE_PRE + MemcacheConfig.getConditionByKey(Constants.CONDITION) + "/"
        + context.getTuiguangStrategy().name() + "/" + cityURL;
```

