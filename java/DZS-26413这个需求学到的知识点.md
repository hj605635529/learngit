# DZS-26413这个需求学到的知识点

- resultList = Optional.ofNullable(resultList).orElse(Collections.emptyList());  如果resultList为空，则返回空的集合，否则就是原来的集合。

- StringUtils.isNotEmpty(hotelSeq)  判断字符串不为空
-  CollectionUtils.intersection(initialCandidates, effectiveTuiguangHotels)); 两个集合求交集

```
CollectionUtils.isNotEmpty(cityPriceRangeItemList)  集合不为空
```


```java
HashMap<String, Integer> objectObjectHashMap = Maps.newHashMap();
objectObjectHashMap.put("11",1);
objectObjectHashMap.put("22",2);
objectObjectHashMap.put("33",3);
objectObjectHashMap.put("44",4);

Integer s = objectObjectHashMap.get("22");
System.out.println(s);
Integer s1 = objectObjectHashMap.get("55");
System.out.println(s1);

Integer integer = objectObjectHashMap.get(null);
System.out.println(integer);
```

结果：

```java
2
null
null
```



假设我们现在从数据库中查到一个map集合：

Map<String,Object> map= baseDao.findFirst(sql);

通常我们判断是否为空或null，需要写"map==null || map.isEmpty"；我们可以使用MapUtils的isEmpty方法来直接判断“MapUtils.isEmpty(map)".

```java
public static boolean isEmpty(Map map) {
    return (map == null || map.isEmpty());
}
```

MapUtils.getObject(seqMedalMap, hotelSeq, TuiguangMedalType.ERROR)

```java
public static Object getObject( Map map, Object key, Object defaultValue ) {
    if ( map != null ) {
        Object answer = map.get( key );
        if ( answer != null ) {
            return answer;
        }
    }
    return defaultValue;
}
```



得到位置的候选集合做了两步：

遍历每一个位置，第一步在刚开始的集合中找到满足奖牌等于这个位置的奖牌，剔除掉侯选集合中酒店的位置在这插入位置的前面的集合。

第二步：这个位置的侯选集合和原来这个位置的酒店做比较，满足评分，档次，价格 才能成为这个位置的真真侯选集合。

2,4,6同城搜索的时候， 距离分为两段， 一段是0,500, 另一段是500-5000, 优先挑选出满足500米之内的酒店， 如果没有的话，再挑出500-5000米的酒店。



默认情况下，赋值运算符右侧的实数被视为 double。 但是，如果希望整数被视为 double，请使用后缀 d 或 D





```
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
Date fromDate = null;
try {
   fromDate = simpleDateFormat.parse(tempFromDate);
} catch (ParseException e) {
   LOGGER.error("日期转换失败", e.getMessage());
   return -1;
}
```



```
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
```

```
String currDate = "2018-10-23";
DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("yyyy-MM-dd");
DateTime parse = DateTime.parse(currDate, dateTimeFormatter);

Date date = parse.toDate();
System.out.println(date);
```







```
package org.apache.commons.lang3.math;
```

```
FLOAT_ZERO.equals(info.getReferenceScore()
```


```
if ((!promotionList.contains(hotelItem)) && (hotelExposureNumber < exposureLimit)) {
   promotionList.add(hotelItem);
}
contains需要重写equal函数。 这是个大坑
```



## 代码规范

1. 在search项目中MobileHotelReRankHandler类中的reRank方法中调用新策略的方法。 需要外界的资源：SearchContext上下文，召回酒店resultList，参数SearchParm。
2. 在rank-common项目中StrategyType枚举中加上新策略的名字，在HotelItem中添加scenePromotion标记字段。
3. 在search项目中BaseHotel也加上scenePromotion这个字段。
4. 在search项目中BaseGenerateHotelService中的fillCommonAttrs方法中填充这个标记到返回值中。
5. 在Qconfig中写配置文件，每个桶下面只会生效一个策略， 因此推广位置只需要配置场景和桶的关系就好了，解析这个配置文件，拿到推广位置。
6. 在common项目中的RedisUtil工具类中添加获取酒店当天的曝光值和曝光值增加的方法。









 

1. ```
   Collections.sort(weightList, (o1, o2) -> o2.getKey().compareTo(o1.getKey()));
   ```

```
 Comparator.comparingDouble(HotelItem::getCityIndivScore).reversed();
```



```
pvMap = RedisUtil.getMap4Gps(key);  具体怎么实现，需要看下
```

```
MutableTriple<Integer, Integer, PromotionLevel
```

