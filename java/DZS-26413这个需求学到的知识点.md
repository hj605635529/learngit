# DZS-26413这个需求学到的知识点

- resultList = Optional.ofNullable(resultList).orElse(Collections.emptyList());  如果resultList为空，则返回空的集合，否则就是原来的集合。

- StringUtils.isNotEmpty(hotelSeq)  判断字符串不为空
-  CollectionUtils.intersection(initialCandidates, effectiveTuiguangHotels)); 两个集合求交集

```
CollectionUtils.isNotEmpty(cityPriceRangeItemList)  集合不为空
```


```java
HashMap<String, Integer> objectObjectHashMap = Maps.newHashMap();
objectObjectHashMap.put("11",1);
objectObjectHashMap.put("22",2);
objectObjectHashMap.put("33",3);
objectObjectHashMap.put("44",4);

Integer s = objectObjectHashMap.get("22");
System.out.println(s);
Integer s1 = objectObjectHashMap.get("55");
System.out.println(s1);

Integer integer = objectObjectHashMap.get(null);
System.out.println(integer);
```

结果：

```java
2
null
null
```



假设我们现在从数据库中查到一个map集合：

Map<String,Object> map= baseDao.findFirst(sql);

通常我们判断是否为空或null，需要写"map==null || map.isEmpty"；我们可以使用MapUtils的isEmpty方法来直接判断“MapUtils.isEmpty(map)".

```java
public static boolean isEmpty(Map map) {
    return (map == null || map.isEmpty());
}
```

MapUtils.getObject(seqMedalMap, hotelSeq, TuiguangMedalType.ERROR)

```java
public static Object getObject( Map map, Object key, Object defaultValue ) {
    if ( map != null ) {
        Object answer = map.get( key );
        if ( answer != null ) {
            return answer;
        }
    }
    return defaultValue;
}
```



得到位置的候选集合做了两步：

遍历每一个位置，第一步在刚开始的集合中找到满足奖牌等于这个位置的奖牌，剔除掉侯选集合中酒店的位置在这插入位置的前面的集合。

第二步：这个位置的侯选集合和这个位置的酒店做比较，满足评分，档次，价格才能成为这个位置的真真侯选集合。



默认情况下，赋值运算符右侧的实数被视为 double。 但是，如果希望整数被视为 double，请使用后缀 d 或 D





```
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
Date fromDate = null;
try {
   fromDate = simpleDateFormat.parse(tempFromDate);
} catch (ParseException e) {
   LOGGER.error("日期转换失败", e.getMessage());
   return -1;
}
```



```
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
```

```
String currDate = "2018-10-23";
DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("yyyy-MM-dd");
DateTime parse = DateTime.parse(currDate, dateTimeFormatter);

Date date = parse.toDate();
System.out.println(date);
```







```
package org.apache.commons.lang3.math;
```

```
FLOAT_ZERO.equals(info.getReferenceScore()
```


```
if ((!promotionList.contains(hotelItem)) && (hotelExposureNumber < exposureLimit)) {
   promotionList.add(hotelItem);
}
contains需要重写equal函数。 这是个大坑
```

